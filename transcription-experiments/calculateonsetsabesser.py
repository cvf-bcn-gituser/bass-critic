# -*- coding: utf-8 -*-
"""CalculateOnsetsAbesser.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QirJ06rQBfJczResCeC0vH3cRvpIinE3
"""

!pip3 install essentia



"""First Task

Define the Duration and Offset measurement techniques.

We already have the onset detection ideas (HFC,)

Evaluate different onset.

Distances with annotation 


Similarity between Ground Truth (annotations) and the output of the algorithm.

Observations on current alg.

It needs to consider short inter-note interval.

Consider "missing green lines":

Can I find a way to 
numericall assess ag similar to student assessment.

Onset, Offset, Duration Measurements,
"""

from google.colab import drive
drive.mount("/content/drive", force_remount=True)
root = '/content/drive/Thesis'
query_music_path = '/content/drive/Thesis'

import pandas as pd
import sys
sys.path.append('/content/drive/Thesis')

sys.path.append('/content/drive/MyDrive/Thesis/IDMT-SMT-BASS_SINGLE-TRACKS/audio')
sys.path.append('/content/drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation')

import os
from essentia.standard import *
from essentia import Pool, array
import matplotlib.pyplot as plt
import numpy as np
import IPython.display as ipd

from lxml import etree

with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/002.xml", "rb") as f:
    tree = etree.parse(f)

golden_onsets2 = []
golden_offsets2 = []
# onsets
print("Onsets2:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets2.append(x.text)
# offsets
print("Offsets2:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets2.append(x.text)


with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/004.xml", "rb") as f:
    tree = etree.parse(f)

golden_onsets4 = []
golden_offsets4 = []
# onsets
print("Onsets4:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets4.append(x.text)
# offsets
print("Offsets4:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets4.append(x.text)


with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/010.xml", "rb") as f:
    tree = etree.parse(f)
golden_onsets10 = []
golden_offsets10 = []
# onsets
print("Onsets10:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets10.append(x.text)
# offsets
print("Offsets10:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets10.append(x.text)


with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/012.xml", "rb") as f:
    tree = etree.parse(f)
golden_onsets12 = []
golden_offsets12 = []
# onsets
print("Onsets12:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets12.append(x.text)
# offsets
print("Offsets12:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets12.append(x.text)



from lxml import etree

with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/002.xml", "rb") as f:
    tree = etree.parse(f)

golden_onsets2 = []
golden_offsets2 = []
# onsets
print("Onsets2:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets2.append(x.text)
# offsets
print("Offsets2:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets2.append(x.text)


with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/004.xml", "rb") as f:
    tree = etree.parse(f)

golden_onsets4 = []
golden_offsets4 = []
# onsets
print("Onsets4:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets4.append(x.text)
# offsets
print("Offsets4:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets4.append(x.text)


with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/010.xml", "rb") as f:
    tree = etree.parse(f)
golden_onsets10 = []
golden_offsets10 = []
# onsets
print("Onsets10:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets10.append(x.text)
# offsets
print("Offsets10:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets10.append(x.text)


with open("drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/annotation/012.xml", "rb") as f:
    tree = etree.parse(f)
golden_onsets12 = []
golden_offsets12 = []
# onsets
print("Onsets12:")
for x in tree.getroot().xpath("//onsetSec"):
    golden_onsets12.append(x.text)
# offsets
print("Offsets12:")
for x in tree.getroot().xpath("//offsetSec"):
    golden_offsets12.append(x.text)

fs=44100

durInSecs2=3
soundsDir = ''

frameSize = 1024*2
hopSize = 512*2
#fileName = os.path.join(soundsDir, file)

the002 = 'drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/audio/002.wav'
the004 = 'drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/audio/004.wav'
the010 = 'drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/audio/010.wav'
the012 = 'drive/MyDrive/Thesis/IDMT-SMT-BASS-SINGLE-TRACKS/audio/012.wav'

g2 = MonoLoader(filename = the002, sampleRate = fs)()
full_length=int(len(g2)/fs)
print(full_length)
durInSecs=19
g2 =g2[:int(durInSecs * fs)]#let's use only the first 8 seconds of the signals
g2= g2 / np.max(np.abs(g2))

g4 = MonoLoader(filename = the004, sampleRate = fs)()
g4 = g4[:int(durInSecs * fs)]#let's use only the first 8 seconds of the signals
g4=  g4 / np.max(np.abs(g4))

g10 = MonoLoader(filename = the010, sampleRate = fs)()
g10 = g10[:int(durInSecs * fs)]#let's use only the first 8 seconds of the signals
g10=  g10 / np.max(np.abs(g10))

g12 = MonoLoader(filename = the012, sampleRate = fs)()
g12 =g12[:int(durInSecs * fs)]#let's use only the first 8 seconds of the signals
g12= g12 / np.max(np.abs(g12))

od1 = OnsetDetection(method='hfc')
od2 = OnsetDetection(method='complex')

# Let's also get the other algorithms we will need, and a pool to store the results
w = Windowing(type = 'hann')
fft = FFT() # this gives us a complex FFT
c2p = CartesianToPolar() # and this turns it into a pair (magnitude, phase)
pool = essentia.Pool()

# Computing onset detection functions.
for frame in FrameGenerator(g2, frameSize = 1024, hopSize = 512):
    mag, phase, = c2p(fft(w(frame)))
    pool.add('features.hfc', od1(mag, phase))
    pool.add('features.complex', od2(mag, phase))

# Phase 2: compute the actual onsets locations
onsets = Onsets()

onsets_hfc = onsets(# this algo expects a matrix, not a vector
                    essentia.array([ pool['features.hfc'] ]),

                    # you need to specify weights, but as there is only a single
                    # function, it doesn't actually matter which weight you give it
                    [ 1 ])

onsets_complex = onsets(essentia.array([ pool['features.complex'] ]), [ 1 ])

print(onsets_complex)

print(onsets_hfc)

print(golden_onsets2)

for onset in onsets_hfc:
    plt.axvline(x=onset*44100, color='red')
plt.plot(g2)
plt.title("Audio waveform and the estimated onset positions (HFC onset detection function)")
plt.show()

for onset in onsets_complex:
    plt.axvline(x=onset*44100, color='red')
plt.plot(g2)
plt.title("Audio waveform and the estimated onset positions (HFC onset detection function)")
plt.show()

!pip3 install mir_eval

import mir_eval
from mir_eval import *

!ls

!ls /content/drive

reference_onsets = mir_eval.io.load_events('/content/drive/MyDrive/Thesis/full_onsets_g2.txt')
estimated_hfc_onsets = mir_eval.io.load_events('/content/drive/MyDrive/Thesis/estimated_hfc_g2.txt')
estimated_complex_onsets = mir_eval.io.load_events('/content/drive/MyDrive/Thesis/estimated_complex_g2.txt')

F, P, R = mir_eval.onset.f_measure(reference_onsets, estimated_hfc_onsets)

print(F, P, R )

F, P, R = mir_eval.onset.f_measure(reference_onsets, estimated_complex_onsets )

print(F, P, R )

durInSecs=5
g2 =g2[:int(durInSecs * fs)]#let's use only the first 8 seconds of the signals
g2= g2 / np.max(np.abs(g2))

#Setting the parameters
windowSize = 1024
hopSize = 512
startIndexes = np.arange(0, g2.size - windowSize, hopSize, dtype = int)#frame/window start indexes
numWindows = startIndexes.size

#Plot time-domain signal and the energy signal
plt.figure(figsize = (12, 4))
plt.subplot(1, 2, 1)
plt.plot(g2)
plt.title('Original sound signal')
plt.ylabel('amplitude')
plt.xlabel('sample indexes')
plt.axis('tight')


#Your code starts here----------
#Write the code to perform windowing and feature estimation
# - features to be computed: energy and maximum amplitude
# - plot energy and maximum amplitude

NRG = np.zeros_like(startIndexes, dtype = float)#initializing the array for keeping energy values
maxVal = np.zeros_like(startIndexes,dtype = float)#initializing the array for maximum values

#Windowing (use variables: startIndexes and numWindows)

#Windowing (use variables: startIndexes and numWindows)
for k in range(numWindows):
    startInd = startIndexes[k]
    x_win = x[startInd : startInd + windowSize]
    NRG[k] = np.sum(np.power(x_win, 2))
    maxVal[k] = np.max(np.abs(x_win))

#Your code ends here----------

#Let's normalize the arrays for the simplicity of viewing them together
NRG = NRG / np.max(NRG)
maxVal = maxVal / np.max(maxVal)
dervNRG = NRG[1:] - NRG[:-1]#let's also compute the derivative of the energy and plot together
dervNRG[dervNRG < 0] = 0
plt.subplot(1, 2, 2)
plt.plot(NRG,label = 'Normalized energy')
plt.plot(maxVal, 'k', label = 'Max-val')
plt.plot(dervNRG, 'r', label = 'NRG derivative')
plt.title('Energy vs maxima')
plt.ylabel('amplitude')
plt.xlabel('sample indexes')
plt.axis('tight')
plt.legend(loc = 'best')
ipd.Audio(x, rate = fs)

#Optional: Plotting maximum amplitude in sync with the waveform
plt.plot(x)
plt.plot(np.arange(maxVal.size) * (x.size / maxVal.size), maxVal, 'r')
plt.plot(np.arange(maxVal.size) * (x.size / maxVal.size), -maxVal, 'r')